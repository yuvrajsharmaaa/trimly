-- Fix database security and structure issues

-- 1. Fix the mutable search_path issue
ALTER FUNCTION public.update_updated_at_column() SECURITY DEFINER SET search_path = public;

-- 2. Create or replace the updated_at trigger function with proper security
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER;

-- 3. Recreate tables with proper structure
-- Drop existing tables if they exist
DROP TABLE IF EXISTS clicks CASCADE;
DROP TABLE IF EXISTS urls CASCADE;

-- Create URLs table
CREATE TABLE urls (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    original_url TEXT NOT NULL,
    short_url TEXT UNIQUE NOT NULL,
    custom_url TEXT UNIQUE,
    qr_code TEXT,
    clicks INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create clicks table
CREATE TABLE clicks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    url_id BIGINT REFERENCES urls(id) ON DELETE CASCADE,
    ip TEXT,
    user_agent TEXT,
    referer TEXT,
    country TEXT,
    city TEXT,
    device TEXT,
    browser TEXT,
    os TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 4. Add updated_at trigger to urls table
DROP TRIGGER IF EXISTS set_updated_at ON urls;
CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON urls
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 5. Enable Row Level Security
ALTER TABLE urls ENABLE ROW LEVEL SECURITY;
ALTER TABLE clicks ENABLE ROW LEVEL SECURITY;

-- 6. Create RLS policies
-- URLs policies
CREATE POLICY "Public URLs are viewable by everyone" ON urls
    FOR SELECT USING (true);

CREATE POLICY "Users can insert their own URLs" ON urls
    FOR INSERT WITH CHECK (auth.uid() = user_id OR user_id IS NULL);

CREATE POLICY "Users can update their own URLs" ON urls
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own URLs" ON urls
    FOR DELETE USING (auth.uid() = user_id);

-- Clicks policies
CREATE POLICY "Clicks are insertable by anyone" ON clicks
    FOR INSERT WITH CHECK (true);

CREATE POLICY "URL owners can view clicks" ON clicks
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM urls 
            WHERE urls.id = clicks.url_id 
            AND (urls.user_id = auth.uid() OR urls.user_id IS NULL)
        )
    );

-- 7. Create indexes for better performance
CREATE INDEX idx_urls_short_url ON urls(short_url);
CREATE INDEX idx_urls_custom_url ON urls(custom_url);
CREATE INDEX idx_clicks_url_id ON clicks(url_id);

-- 8. Create function to increment click count
CREATE OR REPLACE FUNCTION increment_click_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE urls 
    SET clicks = clicks + 1 
    WHERE id = NEW.url_id;
    RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER;

-- Create trigger for click count
DROP TRIGGER IF EXISTS increment_clicks ON clicks;
CREATE TRIGGER increment_clicks
    AFTER INSERT ON clicks
    FOR EACH ROW
    EXECUTE FUNCTION increment_click_count();

-- Insert a test URL to verify everything works
INSERT INTO urls (original_url, short_url, custom_url) 
VALUES 
    ('https://www.google.com', 'test123', 'google')
ON CONFLICT DO NOTHING;

-- Verify the setup
SELECT * FROM urls LIMIT 5; 